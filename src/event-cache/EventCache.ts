import { Session, SessionManager } from '../sessions/SessionManager';
import { v4 } from 'uuid';
import { MetaData } from '../events/meta-data';
import { Config } from '../orchestration/Orchestration';
import { PageManager } from '../sessions/PageManager';
import {
    ApplicationDetails,
    EventBatch,
    UserDetails,
    Event
} from '../dispatch/dataplane';

/**
 * A cache which stores events generated by telemetry plugins.
 *
 * The event cache stores meta data and events until they are dispatched to the
 * data plane. The event cache removes the oldest event once the cache is full
 * and a new event is added.
 */
export class EventCache {
    private applicationDetails: ApplicationDetails;
    private config: Config;

    private events: Event[] = [];

    private sessionManager: SessionManager;
    private pageManager: PageManager;

    private enabled: boolean;

    /**
     * @param applicationDetails Application identity and version.
     * @param batchLimit The maximum number of events that will be returned in a batch.
     * @param eventCacheSize  The maximum number of events the cache can contain before dropping events.
     * @param sessionManager  The sessionManager returns user id, session id and handles session timeout.
     * @param pageManager The pageManager returns page id.
     */
    constructor(applicationDetails: ApplicationDetails, config: Config) {
        this.applicationDetails = applicationDetails;
        this.config = config;
        this.enabled = true;
        this.pageManager = new PageManager(config, this.recordEvent);
        this.sessionManager = new SessionManager(
            config,
            this.recordSessionInitEvent,
            this.pageManager
        );

        if (this.isCurrentUrlAllowed()) {
            this.sessionManager.getSession();
        }
    }

    /**
     * The event cache will record new events or new meta data.
     */
    public enable(): void {
        this.enabled = true;
    }

    /**
     * The event cache will not record new events or new meta data. Events and
     * meta data which are already in the cache will still be accessible.
     */
    public disable(): void {
        this.enabled = false;
    }

    /**
     * Update the current page interaction for the session.
     */
    public recordPageView = (pageId: string) => {
        if (this.isCurrentUrlAllowed()) {
            // There may not be an active session.
            this.sessionManager.getSession();
            this.pageManager.recordPageView(pageId);
        }
    };

    /**
     * Add an event to the cache and reset the session timer.
     *
     * If the session is being recorded, the event will be recorded.
     * If the session is not being recorded, the event will not be recorded.
     *
     * @param type The event schema.
     */
    public recordEvent = (type: string, eventData: object) => {
        if (!this.enabled) {
            return;
        }

        if (this.isCurrentUrlAllowed()) {
            const session: Session = this.sessionManager.getSession();
            this.sessionManager.incrementSessionEventCount();

            if (
                session.record &&
                (session.eventCount <= this.config.sessionEventLimit ||
                    this.config.sessionEventLimit <= 0)
            ) {
                // Only record the event if the session is being recorded.
                this.addRecordToCache(type, eventData);
            }
        }
    };

    /**
     * Returns the current session (1) if a session exists and (2) if the
     * current URL is allowed. Returns undefined otherwise.
     */
    public getSession = (): Session | undefined => {
        if (this.isCurrentUrlAllowed()) {
            return this.sessionManager.getSession();
        }
        return undefined;
    };

    /**
     * Returns true if there are one or more events in the cache.
     */
    public hasEvents(): boolean {
        return this.events.length !== 0;
    }

    /**
     * Removes and returns the next batch of events.
     */
    public getEventBatch(): EventBatch {
        const eventBatch: EventBatch = {
            application: this.applicationDetails,
            batchId: v4(),
            user: this.getUserDetails(),
            events: []
        };

        if (this.events.length === 0) {
            return eventBatch;
        }

        if (this.events.length <= this.config.batchLimit) {
            // Return all events.
            eventBatch.events = this.events;
            this.events = [];
        } else {
            // Dispatch the front of the array and retain the back of the array.
            eventBatch.events = this.events.splice(0, this.config.batchLimit);
        }

        return eventBatch;
    }

    /**
     * Add a session start event to the cache.
     */
    private recordSessionInitEvent = (
        session: Session,
        type: string,
        eventData: object
    ) => {
        if (!this.enabled) {
            return;
        }
        if (session.record) {
            this.addRecordToCache(type, eventData);
        }
    };

    /**
     * Add an event to the cache.
     * @param type The event schema.
     */
    private addRecordToCache = (type: string, eventData: object) => {
        if (!this.enabled) {
            return;
        }

        if (this.events.length === this.config.eventCacheSize) {
            // Make room in the cache by dropping the oldest event.
            this.events.shift();
        }

        // The data plane service model (i.e., LogEvents) does not adhere to the
        // RUM agent data model, where sessions and pages are first class
        // objects with their own attribute sets. Instead, we store session
        // attributes and page attributes together as 'meta data'.
        const metaData: MetaData = {
            version: '1.0.0',
            ...this.sessionManager.getAttributes(),
            ...this.pageManager.getAttributes()
        };

        this.events.push({
            details: JSON.stringify(eventData),
            id: v4(),
            metadata: JSON.stringify(metaData),
            timestamp: new Date(),
            type
        });
    };

    /**
     * Returns {@code true} if the current url matches one of the allowedPages
     * and does not match any of the deniedPages; returns {@code false}
     * otherwise.
     */
    private isCurrentUrlAllowed() {
        const location = document.location.toString();

        if (
            this.config.pagesToExclude.length > 0 &&
            this.config.pagesToExclude.some((re) => re.test(location))
        ) {
            return false;
        }

        if (
            !this.config.pagesToInclude.length ||
            this.config.pagesToInclude.some((re) => re.test(location))
        ) {
            return true;
        }
    }

    private getUserDetails(): UserDetails {
        return {
            userId: this.sessionManager.getUserId(),
            sessionId: this.sessionManager.getSession().sessionId
        };
    }
}
